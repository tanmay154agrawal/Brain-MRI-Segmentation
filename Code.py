# -*- coding: utf-8 -*-
"""Cv_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QHgQ1T1TfiunxicNHws3FC1-t49nUcIl
"""

import os
import cv2
import numpy as np
import imutils
from scipy.stats import skew
from google.colab.patches import cv2_imshow
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from skimage import io, filters, segmentation, color,measure,morphology

!unzip /content/Dataset.zip -d /content/Dataset

folders=["/content/Dataset/no","/content/Dataset/yes"]

images=[]
for i,folder in enumerate(folders):
  for file in os.listdir(folder):
    # if file.endswith(".jpg" or ".JPG"):
      img_path=os.path.join(folder,file)        # path of images joined using os
      img=cv2.imread(img_path,0)
      img=img.astype('uint8')   
      images.append((img,i))              # Labels are the index values

len(images)

images[10][0].shape

"""***Preprocessing and Skull Stripping***"""

mri_image=[]
set=[]
for mri,i in images:
   img=cv2.resize(mri, (256,256), interpolation=cv2.INTER_LINEAR)
   _, thresh = cv2.threshold(img, 20, 255, cv2.THRESH_BINARY)
   kernel = np.ones((4,4), np.uint8)
  #  opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=3)
   # Perform morphological closing to fill in gaps
   closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=7)
   # Define erosion kernel
   kernel = np.ones((3,3), np.uint8)  # Increase kernel size
   # Erode foreground
   eroded = cv2.erode(closing, kernel, iterations=10)
   # Apply binary mask to original image
   stripped = cv2.bitwise_and(img, eroded)
   cv2_imshow(stripped)
   set.append((stripped,i))
   mri_image.append(mri)

cv2_imshow(set[135][0])

cv2_imshow(images[134][0])

"""***Data Augmentation***"""

yes=0
no=0
for _,i in set:
  if i==1:
    yes+=1
  elif i==0:
    no+=1
print(yes,no)

for idx,mri in enumerate(set):
  mri,i= mri
  if i==0 and idx%3==0:
    img_adjusted = cv2.convertScaleAbs(mri, alpha=1.5, beta=0)
    set.append((img_adjusted,i))

"""***Using Random Forest as standard ML model***"""

def ML_model(X,Y):
  X_train, X_test, y_train, y_test = train_test_split(X,Y , test_size=0.2, random_state=42)
  clf = RandomForestClassifier(n_estimators=100)
  clf.fit(X_train, y_train)
  accuracy = clf.score(X_test, y_test)
  print("Accuracy:", accuracy)

"""***Using Image segments for classification***"""

X=[]
Y=[]
for mri,i in set:
  # _,tresh=cv2.threshold(mri,120,255,cv2.THRESH_OTSU)
  kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
  opening = cv2.morphologyEx(mri, cv2.MORPH_OPEN, kernel)
  closing = cv2.morphologyEx(opening, cv2.MORPH_CLOSE, kernel)
  dist_transform = cv2.distanceTransform(mri, cv2.DIST_L2, 5)
  ret, markers = cv2.threshold(dist_transform, 0.5*dist_transform.max(), 255, cv2.THRESH_BINARY)
  markers = cv2.connectedComponents(markers.astype(np.uint8))[1]
  # mri=cv2.cvtColor(mri,cv2.COLOR_GRAY2BGR)
  # markers = cv2.watershed(mri, markers)
  # mri[markers == -1] = [255, 0, 0]
  # cv2_imshow(mri)
  features = np.ravel(markers)
  X.append(features)
  Y.append(i)

ML_model(X,Y)

"""***Using Intensity based features***"""

def entropy(img):
    hist = cv2.calcHist([img], [0], None, [256], [0, 256])
    hist_norm = cv2.normalize(hist, None).flatten()
    entropy = -sum(p * np.log2(p) for p in hist_norm if p != 0)
    return entropy

X=[]
Y=[]
for mri,i in set:
  ent=entropy(mri)
  ent = np.where(np.isnan(ent), 0, ent)
  std_dev = np.std(mri)
  std_dev = np.where(np.isnan(std_dev), 0, std_dev)
  sk = skew(np.ravel(mri))
  sk = np.where(np.isnan(sk), 0, sk)
  X.append((ent,std_dev,sk))
  Y.append(i)

ML_model(X,Y)

"""***Image Segmentation using Kmeans***"""

segment=[]
for mri,i in set:
  if i==1:
    mri1=mri.copy()
    data = np.float32(mri1.reshape((-1, 1)))
    # print(np.sum(data))
    K = 5
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
    ret, label, center = cv2.kmeans(data, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    intensity = np.zeros(K)
    for i in range(K):
       cluster_pixels = data[label == i]
       intensity[i] = np.mean(cluster_pixels)
    # print("Intensity of clusters: ", intensity)
    idx=np.argmax(intensity)
    label=label.reshape(mri.shape)
    mask = np.uint8(label==idx)
    mri[mask==0] = [0]
    cv2_imshow(mri1)
    segment.append(mri1)

"""***Postprocessing***"""

tumours=[]
tumour_size=[]
for tumour in segment: 
  contours, hierarchy = cv2.findContours(tumour, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  largest_contour = None
  max_area = 0
  img=mask = np.zeros_like(tumour)
  for contour in contours:
      area = cv2.contourArea(contour)
      if area > max_area:
          largest_contour = contour
          max_area = area
  tumour_size.append(max_area)
  cv2.fillPoly(img, pts=[largest_contour], color=255)
  tumours.append(img)
  # cv2.drawContours(img, [largest_contour], 0, 255, 2)
  cv2_imshow(img)

plt.scatter(range(len(tumour_size)), tumour_size, s=30)
plt.ylim(0, 10000)
plt.xlabel('Tumor index')
plt.ylabel('Tumor area')

img=[]
for mri,i in set:
  if i==1:
    img.append(mri)

for tumour,orig in zip(tumours,img):
  fig, axes = plt.subplots(ncols=2, figsize=(8, 2.7))
  ax0,ax1= axes
  ax0.imshow(orig)
  ax0.set_title('original')
  ax1.imshow(tumour)
  ax1.set_title('segmented')

"""***Watershed Algorithm***"""

from skimage.segmentation import watershed
from skimage.feature import peak_local_max
from scipy import ndimage

for mri,i in set:
  if i==1:
    thresh_value = 120
    binary = mri > thresh_value
    # Calculating distance transform 
    distance = ndimage.distance_transform_edt(binary)
    # Finding maxima in the distance array
    local_maxi = peak_local_max(distance, indices=False, footprint=np.ones((3, 3)),labels=binary) 
    # Providing labels to different local maximas
    markers = ndimage.label(local_maxi)[0] 
    labels = watershed(distance, markers, mask=binary)
    fig, axes = plt.subplots(ncols=2, figsize=(8, 2.7))
    ax0, ax1 = axes
    plt.gray()
    ax0.imshow(mri)
    ax0.set_title('Original')
    ax1.imshow(labels, cmap=plt.cm.nipy_spectral)
    ax1.set_title('Segmented')

